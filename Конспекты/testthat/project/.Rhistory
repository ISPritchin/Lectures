bmiData
#выставить следующие оценки (по значению bmi)
#16 и менее	Выраженный дефицит массы тела
#16—18,5	Недостаточная (дефицит) масса тела
#18,5—25	Норма
#25—30	Избыточная масса тела (предожирение)
#30—35	Ожирение первой степени
#35—40	Ожирение второй степени
#40 и более	Ожирение третьей степени (морбидное)
bmiData$res <-
case_when(
bmiData$BMI < 16 ~ "Выраженный дифицит массы тела",
between(bmiData$BMI, 16, 18.5) ~ "Недостаточная (дефицит) масса тела",
between(bmiData$BMI, 18.5, 25) ~ "Норма",
between(bmiData$BMI, 25, 30) ~ "Избыточная масса тела (предожирение)",
between(bmiData$BMI, 30, 35) ~ "Ожирение первой степени",
between(bmiData$BMI, 35, 40) ~ "Ожирение второй степени",
bmiData$BMI > 40 ~ "Ожирение третьей степени",
TRUE ~ NA_character_
)
bmiData
print(data)
print(data, n = 87)
print(bmiData, n = 87)
print(filter(bmi, is.na(res)))
print(filter(bmiData, !is.na(res)))
print(filter(bmiData, !is.na(res)), 500)
print(filter(bmiData, !is.na(res)), n = 500)
print(filter(bmiData, !is.na(res)) %>% arrange(bmiData$res), n = 500)
print(filter(bmiData, !is.na(res)) %>% arrange(res), n = 500)
print(filter(bmiData, !is.na(res)) %>% arrange(BMI), n = 500)
print(filter(bmiData, !is.na(res)) %>% arrange(BMI), n = 500)
n <- 12
h <- 1/(n-1)
r = seq(h, 1, length.out=n)
theta = seq(0, 2*pi, length.out=36)
g <- expand.grid(r=r, theta=theta)
x <- c(g$r * cos(g$theta),0)
y <- c(g$r * sin(g$theta),0)
z <- sin(x*y)
m <- matrix(
c(x,y,z),
ncol = 3,
dimnames = list(NULL, c("x", "y", "z"))
)
tri <- delaunayn(m[,1:2])
# now figure out the colormap
zmean <- apply(tri,MARGIN=1,function(row){mean(m[row,3])})
library(scales)
tri <- delaunayn(m[,1:2])
install.packages("heatmaply")
library("heatmaply")
heatmaply(mtcars, k_row = 3, k_col = 2)
heatmaply(iris, k_row = 3, k_col = 2)
lego_colors <- read_csv("LEGOMosaic/Lego_Colors.csv") %>%
filter(c_Palette2016, !c_Transparent, !c_Glow, !c_Metallic) %>%
mutate_at(vars(R, G, B), funs(./255)) %>%
rename(R_lego = R, G_lego = G, B_lego = B)
library(magrittr)
lego_colors <- read_csv("LEGOMosaic/Lego_Colors.csv") %>%
filter(c_Palette2016, !c_Transparent, !c_Glow, !c_Metallic) %>%
mutate_at(vars(R, G, B), funs(./255)) %>%
rename(R_lego = R, G_lego = G, B_lego = B)
lego_colors <- read_csv("LEGOMosaic/Lego_Colors.csv") %>%
filter(c_Palette2016, !c_Transparent, !c_Glow, !c_Metallic) %>%
mutate_at(vars(R, G, B), funs(./255)) %>%
rename(R_lego = R, G_lego = G, B_lego = B)
library(dplyr)
lego_colors <- read_csv("LEGOMosaic/Lego_Colors.csv") %>%
filter(c_Palette2016, !c_Transparent, !c_Glow, !c_Metallic) %>%
mutate_at(vars(R, G, B), funs(./255)) %>%
rename(R_lego = R, G_lego = G, B_lego = B)
knitr::opts_chunk$set(echo = TRUE)
starwars
starwars %>% filter_all(any_vars(is.na(.)))
starwars %>% select_if(is.numeric)
data %>% filter_all(any_vars(is.na(.)))
data %>% select_if(is.numeric)
data %>% filter_all(any_vars(is.na(.)))
data %>% select_if(is.numeric)
data %>% filter_all(any_vars(is.na(.)))
data %>% select_if(is.numeric)
data %>% select_if(is.numeric)
data
library("knitr")
set.seed(100)
library("plotpy")
library("plot_ly")
library("plotly")
x = 1 + rnorm(200, 3, 2)
mean(x)
var(x)
plotly(
x = ~x
type = "histogram"
)
plotly(
x = ~x,
type = "histogram"
)
plotly(
x = ~x,
type = "histogram"
)
plotly(
data = x
x = ~x,
type = "histogram"
)
plotly(
data = x,
x = ~x,
type = "histogram"
)
library("plotly")
plot_ly(data = iris, x = ~Sepal.Length, y = ~Petal.Length)
install.packages("webshot")
webshot::install phantomjs()
install.packages("webshot")
webshot::install phantomjs()
webshot::install_phantomjs()
plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Petal.Length,
type = "scatter",
mode = "markers"
)
plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Petal.Length,
type = "scatter",
mode = "markers"
)
library("plotly")
plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Petal.Length,
type = "scatter",
mode = "markers"
)
p <- plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Petal.Length,
type = "scatter",
mode = "markers"
)
p
devtools::install_github("wch/webshot")
ggplot() +
geom_point(data = iris, aes(Sepal.Length, Petal.Width))
knitr::opts_chunk$set(echo = TRUE)
plotly(
data = iris,
x = ~Sepal.Length,
y = ~Sepal.Width
)
plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Sepal.Width
)
plot_ly(
data = iris,
x = ~Sepal.Length,
y = ~Sepal.Width,
type = "scatter",
mode = "markers"
)
source("https://bioconductor.org/biocLite.R")
biocLite("ClassifyR")
knitr::opts_chunk$set(echo = TRUE)
library("lubridate")
library("lubridate")
install.packages("lubridate")
library("lubridate")
library("magrittr")
x <- c("09-01-01", "09-01-02", "09-01-03")
ymd(x)
mdy(x)
myd(x)
ymd(090101, 90102)
x <- c(20090101, "2009-01-02", "2009 01 03", "2009-1-4", "2009-1, 5", "Created on 2009 1 6", "200901 !!! 07")
ymd(x)
x <- c("2010-04-14-04-35-59", "2010-04-01-12-00-00")
ymd_hms(x)
ymd("1 Января 2018", locale = "ru_RU.utf8")
ms(c("09:10", "09:02", "1:10"))
ms("6,5")
hm("7 6")
hms("7 6 5", "3:23:::2", "2 : 23 : 33", "Finished in 9 hours, 20 min and 4 seconds")
x <- ("13 year, 2 secs, 3 mins, 1/4 d/month")
parse_date_time(x, "%y %s %m %d/%M")
parse_date_time(x, "%y %s %M %d/%m")
parse_date_time(x, "%y %s %M %d %m")
parse_date_time(x, "ysMdm")
parse_date_time(x, "ysMdm")
parse_date_time(x, "ysMdm")
parse_date_time(x, "ysMdm")
data <- ymd_h(now)
data <- ymd_h(now())
data <- ymd_hms(now())
data
year(data)
currentData <- now()
data <- now()
data <- ymd_hms(data)
data
month(data)
day(data)
quarter(data)
semester(data)
week(data)
tz(data)
yday(data)
qday(data)
mday(data)
wday(data)
wday(data, week_start = 1)
wday(data, week_start = 1)
data
year(data) <- 202
year(data) <- 2020
data
data
month(data) <- 1
day(data) <- 25
data
year(data) <- 2018
day(data) <- 9
wday(data, week_start = 1) <- 1
data
year(data) <- 2018
day(data) <- 9
wday(data, week_start = 1) <- 1
data
year(data) <- 2018
month(data) <- 5
day(data) <- 9
wday(data, week_start = 1) <- 1
data
yday(data) <- 256
data
make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L,
sec = 0, tz = "UTC")
make_date(year = 1970L, month = 1L, day = 1L)
make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 0L,
sec = 0, tz = "UTC")
make_date(year = 1970L, month = 1L, day = 1L)
make_datetime(year = 1970L, month = 1L, day = 1L, hour = 0L, min = 3L,
sec = 0, tz = "UTC")
make_date(year = 1970L, month = 1L, day = 1L)
is.Date(now())
is.Date(now())
now()
now()
is.Date(now())
is.period(x)
x <- seconds(100)
is.period(x)
period(-1, "days")
period(c(3, 1, 2, 13, 1), c("second", "minute", "hour", "day", "week"))
period (second = 90, minute = 5)
period(c(1, -60), c("hour", "minute"), hour = c(1, 2), minute = c(3, 4))
period(c(1, 120), c("hour", "minute"), hour = c(1, 2), minute = c(3, 4))
period("2days 2hours 2mins 23secs")
duration("day 2 sec") > "day 1sec"
"day 2 sec" > "day 1sec"
"day 2 sec" > "day 10 sec"
duration("day 2 sec") > "day 10 sec"
minutes(10)
seconds(1) + minutes(2)
dhours(100)
dhours(100)
dyears(100)
dyears(10)
dweek(1)
dweeks(1)
duration(day = -1)
duration(day = 1)
duration(day = -1) == duration(day = 1)
duration(day = -1)
duration(day = 1)
duration(90, "seconds")
duration(second = 3, minute = 1.5, hour = 2, day = 6, week = 1)
duration(hour = 1, minute = -60)
duration("2hours 2minutes 1second")
duration("day 2 sec") > "day 1sec"
dminutes(3.5)
ddays(1) + dhours(6) + dminutes(30)
x <- ymd_hms("2009-08-03", tz="America/Chicago")
x <- ymd_hms("2009-08-03", tz="America/Chicago")
x <- ymd_hms("2009-08-03", tz="America/Chicago")
x <- ymd("2009-08-03")
x + ddays(1)
x + ddays(2)
x + ddays(-2)
x + ddays(2)
x + ddays(-2)
period(-1, "days")
x <- ymd("2009-08-03")
x + ddays(2)
x + ddays(5)
Sys.sleep(2)
start = now()
Sys.sleep(2)
Sys.sleep(2)
finish = now()
finish = now()
interval(start, end, tzone = tz(start))
end = now()
interval(start, end, tzone = tz(start))
x <- interval(start, end, tzone = tz(start))
int_start(x)
int_end(x)
int_length(x)
int_start(x) <- ymd(20000101)
int_length(x) #длина в секундах
int_start(x) <- ymd(20180101)
int_length(x) #длина в секундах
int_start(x) <- ymd(20180501)
int_length(x) #длина в секундах
x <- interval(start, end, tzone = tz(start))
int_end(x)
int_start(x) <- ymd(20180501)
int_length(x) #длина в секундах
int_flip(start, end)
int_flip(x)
int_start(x) <- ymd(20180501)
x
int_start(x) <- ymd_h(2018050100)
x
int_start(x) <- ymd_h(2018050100)
x
??map
install.packages("broom")
library(tidyr)
df <- data.frame(x = c(NA, "a-b", "a-d", "b-c", "d-e"))
df %>% extract(x, "A")
df %>% extract(x, c("A", "B"), "([[:alnum:]]+)-([[:alnum:]]+)")
df %>% extract(x, c("A", "B"), "([[:alpha:]]+)-([[:alpha:]]+)")
df %>% extract(x, c("A", "B"), "([a-d]+)-([a-d]+)")
broom::tidy(t.test(norm(100)))
broom::tidy(shapiro.test(norm(100)))
x = shapiro.test(norm(100))
x = shapiro.test(rnorm(100))
broom::tidy(x)
res <- broom::tidy(x)
res$method
shapiro.test(rnorm(100))
x = shapiro.test(rnorm(100))
res <- broom::tidy(x)
res
install.packages(usethis)
install.packages("usethis")
install.packages("usethis")
library(usethis)
tmp <- file.path(tempdir(), "mypkg")
usethis::create_package(tmp)
tempdir()
install.packages("stubtest")
install.packages("stubthat")
library(stubthat)
jedi_or_sith <- function(x) {
return('No one')
}
jedi_or_sith()
jedi_or_sith_stub <- stub(jedi_or_sith)
jedi_or_sith_stub$withArgs(x = 'Luke')$returns('Jedi')
jedi_or_sith('Luke')
jedi_or_sith_stub$f('Luke')
real.roots <- function(a, b, c)
{
if (a == 0.) {
warning("Leading term cannot be zero");
return(linear(b, c))
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
return(res)
}
library(rstudioapi)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd()
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_length(roots, 1)
expect_equal(roots, -3000)
# Test whether ABSOLUTE error is within 0.1
expect_equal(roots, -3000.01, tolerance  = 0.1)
expect_equal(roots, -3001, tolerance  = 0.1, scale=-3001)
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_error(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_error(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_error( real.roots(0, 2, 3), "[zZ]ero")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
library(testthat)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd()
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_length(roots, 1)
expect_equal(roots, -3000)
# Test whether ABSOLUTE error is within 0.1
expect_equal(roots, -3000.01, tolerance  = 0.1)
expect_equal(roots, -3001, tolerance  = 0.1, scale=-3001)
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_error(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_error(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_error( real.roots(0, 2, 3), "[zZ]ero")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_warning(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_warning(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_warning( real.roots(0, 2, 3), "[zZ]ero")
})
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_is(roots, "numeric")
expect_length(roots, 2)
expect_true(roots[1] < roots[2])
})
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_is(roots, "numeric")
expect_length(roots, 2)
expect_true(roots[1] < roots[2])
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_warning(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_warning(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_warning( real.roots(0, 2, 3), "[zZ]ero")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
?test_dir
devtools::use_testthat()
usethis::use_testthat()
install.packages(c("devtools", "roxygen2"
install.packages(c("devtools", "roxygen2"))
install.packages(c("devtools", "roxygen2"))
install.packages(c("devtools", "roxygen2"))
