a <- 10
expect_lte(10, 10)
a <- 9
expect_lt(a, 10)
a <- 11
expect_lt(a, 10)
a <- 9
expect_lt(a, 10)
a <- 10
expect_lte(10, 10)
a <- 11
expect_lt(a, 10)
a <- 9
expect_lt(a, 10)
a <- 10
expect_lte(10, 10)
library(testthat)
expect_output(str(mtcars), "32 obs")
expect_output(str(mtcars), "32 obs")
expect_output(str(mtcars), "32 obs")
expect_output(str(mtcars), "11 VARIABLES", ignore.case = TRUE)
f <- function(x) {
if (x < 0)
message("*x* is already negative")
-x
}
expect_message(f(-1), "*x*", fixed = TRUE)
expect_message(f(-1), ".x.", fixed = TRUE)
expect_message(f(-1), ".x.", fixed = TRUE)
expect_message(f(1), NA)
f <- function(x) {
if (x < 0)
message(".x. is already negative")
-x
}
expect_message(f(-1), ".x.*", fixed = TRUE)
expect_message(f(-1), ".x.", fixed = TRUE)
expect_message(f(-1), "already NEGATIVE", ignore.case = TRUE)
expect_message(f(-1), regexp = "NEG..I",)
expect_message(f(-1), regexp = "NEG..I", ignore.case = TRUE)
#Предупреждения
f <- function(x) {
if (x < 0) warning("*x* is already negative")
-x
}
expect_warning(f(-1))
expect_warning(f(-1))
expect_warning(f(-1), "already NEGATIVE", ignore.case = TRUE)
expect_warning(f(-1), regexp = "NEG..I", ignore.case = TRUE)
#Предупреждения
f <- function(x) {
if (x < 0) warning(".x. is already negative")
-x
}
expect_warning(f(1), NA)
expect_warning(f(-1), ".x.", fixed = TRUE)
f(-1)
f(-1)
expect_warning(f(-1))
# Ошибки
f <- function() stop("My error!")
expect_error(f())
f()
expect_error(f())
expect_error(f(), "My error!")
expect_error(f(), "my error!", ignore.case = TRUE)
expect_silent(f())
expect_silent(f(1))
expect_silent(f(1))
f <- function(x) {
if (x < 0)
message(".x. is already negative")
-x
}
expect_silent(f(1))
test_that("skip example", {
expect_equal(1, 1L)    # this expectation runs
skip('skip')
expect_equal(1, 2)     # this one skipped
expect_equal(1, 3)     # this one is also skipped
})
test_that("skip example", {
expect_equal(1, 1L)    # this expectation runs
skip('skip')
expect_equal(1, 2)     # this one skipped
expect_equal(1, 3)     # this one is also skipped
})
if (FALSE) skip("No internet connection")
test_that("this test fails", fail())
test_that("this test succeeds", succeed())
test_that("this test succeeds", succeed())
real.roots <- function(a, b, c)
{
if (a == 0.)
stop("Leading term cannot be zero")
d = b*b - 4*a*c # discriminant
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
source("real_roots.R")
source("code.R")
source("code.R")
setwd("../")
getwd()
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd
set_wd()
library(rstudioapi)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd()
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_that( length(roots), equals(1) )
expect_that( roots, equals(-3000) )
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000.01, tolerance  = 0.1) )
expect_equal( roots, -3001)
})
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000, tolerance  = 0.1) )
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_that( length(roots), equals(1) )
expect_that( roots, equals(-3000) )
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000, tolerance  = 0.1) )
expect_equal( roots, -3001)
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_that( length(roots), equals(1) )
expect_that( roots, equals(-3000) )
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000, tolerance  = 1) )
expect_equal( roots, -3001)
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_that( length(roots), equals(1) )
expect_that( roots, equals(-3000) )
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000, tolerance  = 2) )
expect_equal( roots, -3001)
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_that( length(roots), equals(1) )
expect_that( roots, equals(-3000) )
# Test whether ABSOLUTE error is within 0.1
expect_that( roots, equals(-3000.01, tolerance  = 0.1) )
expect_equal( roots, -3001, tolerance  = 0.1, scale=-3001)
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_that( real.roots(0, 2, 3), throws_error() )
# Test specifically for an error string containing "zero"
expect_that( real.roots(0, 2, 3), throws_error("zero") )
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_that( real.roots(0, 2, 3), throws_error("[zZ]ero") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(2.7) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(2) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(3) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(3) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(5) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(3) )
expect_that( x, is_a("data.frame") )
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_that( length(x), equals(2) )
expect_that( x, is_a("data.frame") )
})
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_length(roots, 1)
expect_equal(roots, -3000)
# Test whether ABSOLUTE error is within 0.1
expect_equal(roots, -3000.01, tolerance  = 0.1)
expect_equal(roots, -3001, tolerance  = 0.1, scale=-3001)
})
# Test for ANY error
expect_error( real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_error(real.roots(0, 2, 3), "zero")
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
expect_named(x)
expect_named(x, c("a", "b", "c"))
x <- c(a = 1, b = 2, c = 3)
expect_named(z, NULL)
expect_named(z, NULL)
expect_named(x, c("a", "b", "c"))
expect_named(z, NULL)
expect_named(x, NULL)
#expect_named(x, NULL)
expect_named(x, c("B", "C", "A"), ignore.order = TRUE, ignore.case = TRUE)
library("test_your_code")
source("test_your_code")
source("test_your_code")
library(rstudioapi)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
source("test_your_code")
source("test_your_code.R")
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
source("test_your_code.R")
library(rstudioapi)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd()
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_length(roots, 1)
expect_equal(roots, -3000)
# Test whether ABSOLUTE error is within 0.1
expect_equal(roots, -3000.01, tolerance  = 0.1)
expect_equal(roots, -3001, tolerance  = 0.1, scale=-3001)
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_error(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_error(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_error( real.roots(0, 2, 3), "[zZ]ero")
})
test_dir()
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
source("functions.R")
library(rstudioapi)
set_wd <- function() {
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path))
}
set_wd()
source("code.R")
test_that("Distinct roots", {
roots <- real.roots(1, 7, 12)
expect_that( roots, is_a("numeric") )
expect_that( length(roots), equals(2) )
expect_that( roots[1] < roots[2], is_true() )
})
test_that("Repeated root", {
roots <- real.roots(1, 6000, 9000000)
expect_length(roots, 1)
expect_equal(roots, -3000)
# Test whether ABSOLUTE error is within 0.1
expect_equal(roots, -3000.01, tolerance  = 0.1)
expect_equal(roots, -3001, tolerance  = 0.1, scale=-3001)
})
test_that("Polynomial must be quadratic", {
# Test for ANY error
expect_error(real.roots(0, 2, 3))
# Test specifically for an error string containing "zero"
expect_error(real.roots(0, 2, 3), "zero")
# Test specifically for an error string containing "zero" or "Zero" using regular expression
expect_error( real.roots(0, 2, 3), "[zZ]ero")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 2)
expect_is(x, "data.frame")
})
test_that("Bogus tests", {
x <- c(1, 2, 3)
expect_length(x, 8)
expect_is(x, "data.frame")
})
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
"x - любое"
}
else {
"решений нет"
}
} else {
-b/a
}
}
real.roots <- function(a, b, c)
{
if (a == 0.) {
warning("Leading term cannot be zero");
rr <- linear(b, c)
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
real.roots(0, 0, 1)
real.roots <- function(a, b, c)
{
if (a == 0.) {
warning("Leading term cannot be zero");
rr <- linear(b, c)
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
res
}
real.roots(0, 0, 1)
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
return(res)
}
real.roots(0, 0, 1)
real.roots <- function(a, b, c)
{
if (a == 0.) {
#warning("Leading term cannot be zero");
rr <- linear(b, c)
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
return(res)
}
real.roots(0, 0, 1)
real.roots(0, 0, 1)
real.roots <- function(a, b, c)
{
if (a == 0.) {
warning("Leading term cannot be zero");
rr <- linear(b, c)
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
return(res)
}
real.roots(0, 0, 1)
real.roots <- function(a, b, c)
{
if (a == 0.) {
warning("Leading term cannot be zero");
return(linear(b, c))
}
d = b*b - 4*a*c
if (d < 0)
rr = c()
else if (d == 0)
rr = c( -b/(2*a) )
else
rr = c( (-b - sqrt(d))/(2*a),
(-b + sqrt(d))/(2*a))
return(rr)
}
linear <- function(a, b) {
if (a == 0) {
if (b == 0) {
res <- "x - любое"
}
else {
res <- "решений нет"
}
} else {
res <- -b/a
}
return(res)
}
real.roots(0, 0, 1)
jedi_or_sith <- function(x) return('No one')
jedi_or_sith <- function(x) {
return('No one')
}
jedi_or_sith()
jedi_or_sith_stub <- stub(jedi_or_sith)
install.packages("stubtest")
