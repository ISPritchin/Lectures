---
title: "Предобработка данных"
author: "Притчин Иван"
date: '17 мая 2018 г '
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#### Среда разработки

Среда разрботки RStudio разделена на 4 составляющие:
ОПИСАНИЕ

Получение спрравки.

#### Объявление переменных

**Переменная** - некоторый объект в памяти компьютера, имеющий имя и значение.
Как и во многих языках с динамической типизацией, тип переменной не должен быть объявлен заранее. Тип переменной определяется присвоением значения, и может быть переопределен при любом последующем присваивании. Существует три способа выполнения данной операции.
```{r}
x = 3
4 -> y
z <- 5
x + y + z
x <- "I'm string"
x
```
Несмотря на то, что изменение типа переменной возможно - оно не рекомендуется.

В руководствах по языку рекомендуется использование последнего варианта `<-`.

#### Векторизованные вычисления
Часто возникает задача создания **вектора** - набора значений одного типа. Существует несколько подходов к формированию вектора. Если у нас есть множество объектов, и мы хотим получить из них вектор, нам стоит использовать функцию `c`.
```{r}
vector <- c(1, 2, -3, -4)
vector
```

Порой мы хотим задать шаг для
```{r}
v <- seq(1, 2, by = 0.1)
v
v <- seq(1, 2, length.out = 3) #length.out - итоговая длина вектора, шаг будет выбран автоматически.
v
```

Часто используемым является приём создания целочисленных вектором через двоеточие. Шаг в таких векторах задать невозможно.
```{r}
1:3
1:-5
```

Если возникает задача склейки двух векторов - используется также функция, для создания вектора, аргументами которой будут склеиваемые последовательности.
```{r}
v1 <- c(1, 2, 3)
v2 <- c(4, 5, 6)
c(v1, v2)
#Также можно смешивать различные варианты использования функции `c`
c(v1, v1, 0, 0, v2)
```

Важным элементом языка R являются векторизованные вычисления. Все операции с векторами будут выполняться с каждым элементом вектора.
```{r}
v <- c(1, -2, 3)
v + 1
v * 2
v > 0
```

Если существуют вектора в равной длиной - действия над ними будут выполняться поэлементно.
```{r}
v1 <- c(1, -2, 3)
v2 <- -v1
v1 + v2
v1 * v2
```

Есть и ещё один аспект поведения операций с векторами. Пусть один вектор имеет длину $n$, а другой вектор - длину $kn$, где $k$ - целое положительное число. Программа сможет произвести действия над такими веторами по следующему принципу:
```{r}
x <- c(1, 2, 3, 4)
y <- c(2, 4)
x + y
x * y
```
Последний приведенный вариант используется редко. Но знать о нём стоит.

Интерпритатор может выполнить операции и над векторами произвольной длиной, однако будет получено предупреждение о совершаемой операции. В данном случае, если при сложении элементы вектора y закончатся, набор значений для последующего сложения будет взят с начала вектора. И такдо тех пор, пока все элементы первого или второго вектора не поучавствуют в сложении.
```{r}
x <- c(1, 2, 3, 4)
y <- c(1, 2, 3)
x + y
y + x
```


Арифметические операции

+         сложение
-         вычитание
*         умножение
/         деление  (5 / 2 = 2.5)
^         возведение в степень (5^2 = 25 или 5**2 = 25)
x %% y    остаток от деления  (5 %% 2 = 1)
x %/% y   целая часть от деления (5 %/% 2 = 2)

Логические операции

<         меньше 
<=        меньше или равно
>         больше
>=        больше или равно
==        проверка на равенство
!=        не равно
!x        не x
x | y     x или y
x & y     x и y

TRUE  можно сокращенно обозначать T
FALSE можно сокращенно обозначать F

Говорить можно о большом количестве действий. Но есть ряд операций над векторами, котоые точно придётся использовать, а привычки кодирования на С могут сыграть плохую роль. Во многих С-подобных языках операция `&` является побитовым умножением, а `&&` - логическим умножением. Очевидно, что побитовые операции не важны для обработки данных, и поэтому данные операторы были зарезервированы под что-то полезное, что ведёт себя не самым привычным образом.
Для логического перемножения двух вектором используется `&`. `&&` перемножит только первые попавшиеся значения по ленивой схеме.
```{r}
v1 <- c(TRUE, FALSE, TRUE)
v2 <- c(FALSE, FALSE, TRUE)
v1 & v2
v1 && v2
```

Стоит отметить, что возможность векторных вычислений позволяет сократить количество циклов в программе, делать код более читаемым, меньше создавать ошибок. Важен и скоростной аспект. Векторные вычисления всегда быстрее аналогов, напименных в стиле языков без поддержки таких вычислений.

Проведем небольшой эксперимент, в котором мы проверим работоспособность векторизованных вычислений.
```{r, message=FALSE}
library("microbenchmark")

inc1a <- function(vector) {
  for (i in 1:length(vector)) {
    vector[i] = vector[i] + 1
  }
  vector
}

inc1b <- function(vector) {
  vector = vector + 1
}

v <- 1:100000
microbenchmark(
  inc1a(v),
  inc1b(v)
)
```

#### Обращение к элементам
Очевидно, что получние значений, хранящихся в векторе - важная задача. Она реализована в R рядом способов. Индексация значений в языке начинается с единицы. Все основные варианты получения значений вектора представлены ниже:
```{r}
v <- c(1, 6, -4, -1, -3, 4)
v[1]  #v[индекс элемента]
v[-1] #получить все элементы, кроме первого
```

Явлется привычным и то, что за квадратные скобки мы можем отправить только одно значение. Так во многих языках программирования. Однако, минимальной единицей в нашем языке является вектор, поэтому, без угрызения совести можем отправить и его
```{r}
v[c(1, 2)]  # получить первый и второй элемент последовательности
v[-c(1, 2)] # получить все элементы, кроме первого и второго
# v[c(1, 2, -3)] - не заработает, так как R не допускает такого смешения
```

Для получения элементов из вектора, может быть подан логический вектор
```{r}
v <- c(1, -2, 3)
v[c(TRUE, FALSE, TRUE)]
```

Вы уже чувствуете, что пойдёт дальше?
```{r}
v <- c(1, 2, -4, -3, -2)
moreThenZero <- v > 0
moreThenZero
v[moreThenZero]
```

А если ещё короче
```{r}
v[v > 0]
```

В квадратные скобки может быть заключено что угодно, что вернёт нам логический вектор. И это удобно.
```{r}
v <- 1:10
v[v %% 2 == 0 & v %/% 2 > 3] #остаток от деления = 0 и целочисленное деление на 2 даёт значение больше 3
smallerThenMean <- v < mean(v)
v[smallerThenMean] # получить все значения, меньшие среднего значения в векторе
```

#### Списки
**Списком** в языке R называется произвольная коллекция объектов (т е поддерживающая смешивание типов).
```{r}
x <- list("a", 1, list(3, 4), c(1, 2))
```

Для обращения к элементам списка используются двойные квадратные скобки. Можно использовать и одинарные, но одинарные возвращают не само значение, а список из одного выбранного элемента. Двойные скобки вернут сам элемент.
```{r}
x[[1]]
class(x[[1]])
x[1]
class(x)
x[[4]][1]
x[[3]][[1]]
```

Список может быть составен из уже созданных переменных. И обращение к элементам может быть осуществлено как по индексу, так и по имени ряда
```{r}
name <- c("Anna", "Ira", "Alex")
age <- c(19, 29, 18)
is_married = c(TRUE, FALSE, FALSE)
res_list <- list(names = name, ages = age, marred = is_married)
names(res_list) #функция names - возвращаени имена коллекций объектов
res_list$names
res_list[[2]]
```

#### data.frame
Однако, самым частоиспользуемым типом данных является data.frame, который является набором столбцов произвольного типа.
Получим DF из элементов, полученных в прошлом примере.
```{r}
data <- data.frame(names = name, ages = age, marred = is_married)
```

Есть ряд встроенных наборов данных для анализа, для демонтрации примеров воспользуемся данными `airquality`
```{r}
head(airquality) 

```